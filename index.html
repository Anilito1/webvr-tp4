<!doctype html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>TP4 - WebVR - Exercice 1</title>
    <!-- A-Frame stable -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <!-- Physics system (cannon-es) -->
  <script src="https://cdn.jsdelivr.net/npm/aframe-physics-system@4.0.1/dist/aframe-physics-system.min.js"></script>
    <script src="./src/controls.js"></script>
  <script src="./src/grabber.js"></script>
    <script src="./src/gun.js"></script>
  <script src="./src/targets.js"></script>
    <style>
      html, body { height: 100%; margin: 0; }
      .hud { position: absolute; top: 8px; left: 8px; color: white; font-family: sans-serif; z-index: 10; }
      .hud code { background: rgba(0,0,0,.35); padding: 2px 6px; border-radius: 4px; }
    </style>
  </head>
  <body>
  <div class="hud">VR: Grip/Squeeze = Prendre | Trigger (tenir) = Tirer | Stick G déplacer | Stick D rotation | Desktop: E prendre/poser, Clic/F tirer | Score: <span id="score">0</span> | ?safe=1 perf<br><span id="dbg"></span></div>

  <a-scene id="scene" renderer="antialias: true; shadowMap.enabled: true; physicallyCorrectLights: true; colorManagement: true" physics="gravity: -9.81; broadphase: SAP; allowSleep: true" webxr="optionalFeatures: local-floor, bounded-floor" background="color: #202630">
      <a-assets id="assets">
        <!-- Optionally place new weapon model (convert your FBX to glb and put in assets/) -->
        <!-- Example: <a-asset-item id="weaponModel" src="./assets/M4A1.glb"></a-asset-item> -->
      </a-assets>
      <!-- LUMIÈRES -->
  <a-entity light="type: ambient; color: #BBB; intensity: 0.4"></a-entity>
  <a-entity id="dirLight" position="2 4 1" light="type: directional; color: #fff; intensity: 1.0; castShadow: true; shadowCameraVisible: false"></a-entity>

      <!-- SOL -->
  <!-- SOL solide (box) pour éviter les traversées -->
  <a-box position="0 -0.05 0" width="40" depth="40" height="0.1" color="#556" material="metalness: 0.2; roughness: 0.8" shadow="receive: true" static-body="shape: box; friction: 0.6; restitution: 0"></a-box>

      <!-- OBJETS 3D -->
  <!-- Cibles fixes supplémentaires: carré et rond du début -->
  <a-box id="cube" class="target grabbable" position="-3 1.2 -6" depth="1" height="1" width="1" color="#4CC3D9" material="metalness: 0.1; roughness: 0.7" shadow="cast: true; receive: true" dynamic-body="shape: box; mass: 1" target-hit></a-box>
  <a-sphere id="sphere" class="target grabbable" position="3 1.75 -6" radius="1.25" color="#EF2D5E" material="metalness: 0.2; roughness: 0.5" shadow="cast: true; receive: true" dynamic-body="shape: sphere; mass: 1.5" target-hit></a-sphere>
  <a-cylinder class="grabbable" position="0 2.0 -6" radius="0.5" height="1.5" color="#FFC65D" material="metalness: 0.3; roughness: 0.6" shadow="cast: true; receive: true" dynamic-body="shape: box; mass: 1; linearDamping: 0.01; angularDamping: 0.01"></a-cylinder>

  <!-- Arme GLB (proche du joueur) -->
  <!-- Gun repositioned closer to initial player start (camera at z=3) -->
  <a-entity id="gun" class="grabbable" position="0.25 1.45 2.6" vr-gun="muzzleOffset: 0 0 -0.35; speed: 12; debug: false" geometry="primitive: box; depth: 0.32; height: 0.14; width: 0.38" material="color: #777; opacity: 0.002; transparent: true" dynamic-body="shape: box; mass: 0.5">
  <a-entity id="gunModel" gltf-model="./assets/pistol.glb" scale="0.75 0.75 0.75" rotation="0 90 0"></a-entity>
      </a-entity>

  <!-- Spawner de cibles (mêmes emplacements à chaque vague) -->
  <a-entity id="targetsRoot" position="0 0 0" target-spawner="delay: 3000; slots: -4 1.2 -8, -2 1.2 -8, 0 1.2 -8, 2 1.2 -8, 4 1.2 -8, -3 2.2 -10, -1 2.2 -10, 1 2.2 -10, 3 2.2 -10"></a-entity>

  <!-- RIG + CAMÉRA + CONTRÔLEURS -->
  <a-entity id="rig" position="0 1.6 3" thumbstick-move-rotate>
    <a-entity id="head" position="0 0 0" camera="near: 0.01" look-controls="pointerLockEnabled: false" wasd-controls-enabled="false">
      <!-- Simple reticle for desktop aiming (tiny white ring) -->
      <a-entity id="reticle" position="0 0 -1" geometry="primitive: ring; radiusInner: 0.002; radiusOuter: 0.004" material="color: #fff; shader: flat; side: double; opacity: 0.85"></a-entity>
    </a-entity>

  <!-- Contrôleur gauche (Quest 3) -->
  <a-entity id="leftHand" laser-controls="hand: left" raycaster="objects: .grabbable; far: 10" controller-grab="hand: left; radius: 0.65; useTrigger: false">
    <a-sphere radius="0.02" color="#66ccff"></a-sphere>
  </a-entity>

  <!-- Contrôleur droit (Quest 3) -->
  <a-entity id="rightHand" laser-controls="hand: right" raycaster="objects: .grabbable; far: 10" controller-grab="hand: right; radius: 0.65; useTrigger: false">
    <a-sphere radius="0.02" color="#ff9966"></a-sphere>
  </a-entity>
      </a-entity>

      <!-- SKY -->
  <a-sky color="#223"></a-sky>
  <!-- In-VR floating hints -->
  <a-entity position="0 2.2 1.2" text="value: Grip/Squeeze = Prendre | Trigger = Tirer | Stick G = Move | Stick D = Snap Turn; align: center; width: 4" rotation="0 180 0"></a-entity>
    </a-scene>
    <script>
      const scene = document.getElementById('scene');
      const params = new URLSearchParams(location.search);
      const safe = params.get('safe') === '1';
      const debug = params.get('debug') === '1';
  const perf = params.get('perf') === '1';
  const noAutoPick = params.get('noautopick') === '1';
  const gunDebug = params.get('gundebug') === '1';
  const showGun = params.get('showgun') === '1' || gunDebug;
  const lockGun = params.get('lockgun') === '1';
  const muzzleParam = params.get('muzzle'); // format: x,y,z or x y z
      if (safe) {
        // Disable heavy effects in safe mode
        scene.setAttribute('fog', 'enabled: false');
        scene.setAttribute('renderer', 'shadowMap.enabled: false');
        const dl = document.getElementById('dirLight');
        if (dl) dl.setAttribute('light', 'castShadow: false');
        const dbg = document.getElementById('dbg');
        if (dbg) dbg.style.display = 'none';
      }
      if (perf) {
        // Extreme perf mode: remove shadows & lower pixel ratio
        scene.renderer && (scene.renderer.setPixelRatio(0.7));
        const dl = document.getElementById('dirLight');
        if (dl) dl.setAttribute('light', 'intensity: 0.8; castShadow: false');
        console.log('[Perf] mode actif');
      }
      // Dynamic weapon loading strategy:
      // 1. ?weaponglb=ExactFile (e.g. myGun.glb or even myGun.glm -> we try alternatives)
      // 2. Else ?weapon=Name (no extension) -> look for assets/Name.glb etc.
      // 3. Fallbacks: try parent directory (../Name.glb) so user can drop file beside project folder.
      // 4. Final fallback: pistol.glb
  // Par défaut on revient au pistolet d'origine
  let weaponName = params.get('weapon') || 'pistol';
      const weaponFileParam = params.get('weaponglb');
      (function(){
        const gm = document.getElementById('gunModel');
        if (!gm) return;
        const placeholder = document.createElement('a-entity');
        placeholder.setAttribute('geometry','primitive: box; depth: 0.25; height: 0.12; width: 0.32');
        placeholder.setAttribute('material','color: #ffcc00; emissive: #664400; emissiveIntensity: 0.4; wireframe: false');
        placeholder.setAttribute('position','0 0 0');
        placeholder.setAttribute('scale','1 1 1');
        gm.parentNode.insertBefore(placeholder, gm);
        let appliedAutoScale = false;
  const longPattern = /m4|ak\b|rifle|scar|awp|shotgun|vector|mp5|mp7|lever|hunting/i;
  // Added lowpoly & revolver keywords so files named "Pistol Low poly" are treated as pistolets
  const pistolPattern = /1911|usp|ruger|pistol|handgun|revolver|low ?poly/i;
        // Build candidate paths list
        const baseFromParam = weaponFileParam ? weaponFileParam : weaponName + '.glb';
        // Normalize .glm (non-standard) → treat as .glb while keeping original first attempt
        const isGLM = /\.glm$/i.test(baseFromParam);
        const baseNoExt = baseFromParam.replace(/\.(glb|gltf|glm)$/i,'');
        const candidates = [];
        if (weaponFileParam) {
          candidates.push('./assets/' + baseFromParam); // user explicit file in assets first
          if (isGLM) candidates.push('./assets/' + baseNoExt + '.glb');
        } else {
          candidates.push('./assets/' + weaponName + '.glb');
          candidates.push('./assets/' + weaponName + '.gltf');
        }
        // Parent folder fallbacks (user dropped file outside project)
        candidates.push('../' + baseNoExt + '.glb');
        candidates.push('../' + baseNoExt + '.gltf');
        // De-dupe while preserving order
        const seen = new Set();
  const finalList = candidates.filter(p=>{ if (seen.has(p)) return false; seen.add(p); return true; });
        let attemptIndex = 0;
  let lastAttemptPath = null;
        console.log('[Weapon] Candidates:', finalList);
        if (!weaponFileParam && params.get('weapon')==null && weaponName==='pistol') {
          try { const dbg=document.getElementById('dbg'); if(dbg) dbg.textContent=(dbg.textContent+' | Arme par défaut: pistol').trim(); } catch(e){}
        }
        const applyInitialScale = ()=>{
          const ref = weaponFileParam || weaponName;
            if (weaponFileParam && !longPattern.test(ref) && !pistolPattern.test(ref)) return; // keep default
            if (longPattern.test(ref)) {
              gm.setAttribute('scale','0.4 0.4 0.4');
              gm.setAttribute('position','0 0.02 0');
            } else if (pistolPattern.test(ref)) {
              gm.setAttribute('scale','0.75 0.75 0.75');
              gm.removeAttribute('position');
            } else {
              gm.setAttribute('scale','0.55 0.55 0.55');
            }
        };
        applyInitialScale();
        const loadNext = ()=>{
          if (attemptIndex >= finalList.length) {
            console.warn('[Weapon] All candidates failed, fallback to pistol.glb');
            gm.setAttribute('gltf-model','./assets/pistol.glb');
            gm.setAttribute('scale','0.75 0.75 0.75');
            if (placeholder && placeholder.parentNode) placeholder.parentNode.removeChild(placeholder);
            // HUD warning visible to user
            try {
              const dbg = document.getElementById('dbg');
              if (dbg) dbg.textContent = (dbg.textContent + ' | Arme non trouvée: place gun.glb dans assets/ et utilise ?weaponglb=gun.glb').trim();
            } catch(e){}
            return;
          }
          const path = finalList[attemptIndex++];
          lastAttemptPath = path;
          console.log('[Weapon] Loading', path);
          gm.setAttribute('gltf-model', path);
        };
        gm.addEventListener('model-loaded', ()=>{
          // Petite temporisation pour éviter effet flash (apparition/disparition)
          if (placeholder && placeholder.parentNode) {
            setTimeout(()=>{ if (placeholder.parentNode) placeholder.parentNode.removeChild(placeholder); }, 150);
          }
          const obj = gm.getObject3D('mesh');
          if (obj) {
            const box = new THREE.Box3().setFromObject(obj);
            if (!box.isEmpty()) {
              const size = new THREE.Vector3(); box.getSize(size);
              const maxDim = Math.max(size.x,size.y,size.z);
              const ref = weaponFileParam || weaponName;
              let target = 0.9;
              if (pistolPattern.test(ref)) target = 0.35;
              if (maxDim > 0 && maxDim < 10) {
                const s = target / maxDim;
                gm.setAttribute('scale', `${s} ${s} ${s}`);
                appliedAutoScale = true;
                console.log('[Weapon] Auto-scale factor', s.toFixed(3));
              }
                if (gunDebug) {
                  console.log('[Weapon][Debug] Box size', size, 'scale', gm.getAttribute('scale'));
                  // Add wireframe bbox helper entity
                  try {
                    const wf = document.createElement('a-entity');
                    wf.setAttribute('geometry', `primitive: box; width: ${size.x.toFixed(3)}; height: ${size.y.toFixed(3)}; depth: ${size.z.toFixed(3)}`);
                    const center = new THREE.Vector3(); box.getCenter(center);
                    wf.setAttribute('position', `${center.x} ${center.y} ${center.z}`);
                    wf.setAttribute('material', 'color: #00ffcc; wireframe: true; opacity: 0.6');
                    gm.appendChild(wf);
                  } catch(e){}
                }
            }
          }
          // HUD success + file name
          try {
            const dbg = document.getElementById('dbg');
            if (dbg && lastAttemptPath) dbg.textContent = (dbg.textContent + ' | Arme chargée: ' + lastAttemptPath.replace(/.*\\/,'')).trim();
            if (noAutoPick) dbg.textContent = (dbg.textContent + ' | autoPick désactivé').trim();
              if (gunDebug) dbg.textContent = (dbg.textContent + ' | debug ON').trim();
          } catch(e){}
          // Manual muzzle override if provided
          if (muzzleParam) {
            const parts = muzzleParam.split(/[;, ]+/).map(parseFloat).filter(n=>!isNaN(n));
            if (parts.length === 3) {
              const gunEnt = document.getElementById('gun');
              if (gunEnt) {
                gunEnt.setAttribute('vr-gun', 'muzzleOffset', parts[0] + ' ' + parts[1] + ' ' + parts[2]);
                console.log('[Weapon] Muzzle override via ?muzzle=', parts);
                try { const dbg = document.getElementById('dbg'); if (dbg) dbg.textContent = (dbg.textContent + ' | muzzle=' + parts.join(',')); } catch(e){}
              }
            } else {
              console.warn('[Weapon] Param ?muzzle= invalide. Utilise ?muzzle=x,y,z');
            }
          }
        });
        gm.addEventListener('model-error', ()=>{
          console.warn('[Weapon] model-error, trying next fallback');
          loadNext();
        });
        setTimeout(()=>{
          if (placeholder && placeholder.parentNode) {
            placeholder.setAttribute('material','color: #ff0000; emissive: #550000; emissiveIntensity: 0.6');
            console.warn('[Weapon] Toujours pas chargé après 3s. Vérifie que le fichier est présent (assets/ ou parent) & extension (.glb).');
          }
        }, 3000);
        loadNext();
      })();
      // Relocate gun near player if spawned too far (e.g., missing model place)
      scene.addEventListener('loaded', ()=>{
        const gun = document.getElementById('gun');
        const head = document.getElementById('head');
        if (gun && head) {
          const gp = gun.object3D.getWorldPosition(new THREE.Vector3());
          const hp = head.object3D.getWorldPosition(new THREE.Vector3());
          if (gp.distanceTo(hp) > 2.5) {
            const forward = new THREE.Vector3(0,0,-1).applyQuaternion(head.object3D.getWorldQuaternion(new THREE.Quaternion()));
            const target = hp.clone().add(forward.multiplyScalar(0.5));
            target.y -= 0.15;
            gun.setAttribute('position', `${target.x} ${target.y} ${target.z}`);
            console.log('[Weapon] Reposition automatique près du joueur');
          }
          if (showGun) {
            try { gun.setAttribute('material','color: #ff22aa; opacity: 0.25; transparent: true'); } catch(e){}
          }
          if (lockGun) {
            try { gun.removeAttribute('dynamic-body'); gun.setAttribute('kinematic-body',''); console.log('[Weapon][Debug] lockgun actif'); } catch(e){}
          }
        }
      });
      if (gunDebug) {
        // Poll visibility a few frames
        let frames=0;
        const gun = document.getElementById('gun');
        function visCheck(){
          frames++;
          if (gun) {
            const obj = gun.object3D;
            if (!obj) return requestAnimationFrame(visCheck);
            const p = obj.getWorldPosition(new THREE.Vector3());
            if (frames<120) requestAnimationFrame(visCheck);
            console.log('[Weapon][Debug] frame', frames,'worldPos', p.x.toFixed(2), p.y.toFixed(2), p.z.toFixed(2));
          }
        }
        requestAnimationFrame(visCheck);
      }
      if (debug) {
        const gun = document.getElementById('gun');
        if (gun) {
          const v = gun.getAttribute('vr-gun') || {};
          gun.setAttribute('vr-gun', Object.entries(v).map(([k,val])=>`${k}: ${val}`).join('; ') + '; debug: true');
        }
        const right = document.getElementById('rightHand');
        if (right) {
          ['triggerdown','gripdown','squeezestart','selectstart'].forEach(ev=>{
            right.addEventListener(ev, ()=>console.log('[RightHand event]', ev));
          });
        }
      }
      scene.addEventListener('enter-vr', ()=>{
        console.log('[VR] enter-vr');
      });
      scene.addEventListener('loaded', ()=>{
        console.log('[Scene] loaded');
      });
      // Simple frame stall watchdog: if no RAF for >1200ms, show alert tip once
      (function(){
        let last = performance.now();
        let warned = false;
        function tick(){
          const now = performance.now();
            const gap = now - last;
            if (!warned && gap > 1200) {
              warned = true;
              console.warn('[Watchdog] Long frame gap ('+Math.round(gap)+'ms). Essayez ?safe=1 ou ?perf=1 ou ?lite=1');
              const hud = document.getElementById('dbg');
              if (hud) hud.textContent = (hud.textContent + ' | Lag détecté: utiliser ?safe=1 ou ?perf=1').trim();
            }
          last = now;
          requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      })();
    </script>
  </body>
</html>
